# Copyright (c) 2016 - present
# QuantumBlack Visual Analytics Ltd (a McKinsey company).
# All rights reserved.
#
# This software framework contains the confidential and proprietary information
# of QuantumBlack, its affiliates, and its licensors. Your use of these
# materials is governed by the terms of the Agreement between your organisation
# and QuantumBlack, and any unauthorised use is forbidden. Except as otherwise
# stated in the Agreement, this software framework is for your internal use
# only and may only be shared outside your organisation with the prior written
# permission of QuantumBlack.
"""
Nodes of the pyplot reports pipeline.
"""
import logging
import datetime
import io
import base64
import os
import re
from pathlib import Path
from typing import Callable, Dict, List, Union
import nbformat as nbf
from PyPDF2 import PdfFileWriter, PdfFileReader
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.offsetbox import TextArea, VPacker, AnnotationBbox
import matplotlib.pyplot as plt


logger = logging.getLogger(__name__)


def _add_metadata(
    pdf: PdfPages, title: str, author: str, subject: str, creation_date: datetime
) -> PdfPages:

    d = pdf.infodict()
    d["Title"] = title
    d["Author"] = author
    d["Subject"] = subject
    d["CreationDate"] = creation_date
    d["ModDate"] = datetime.datetime.today()

    return pdf


def _create_front_page(
    title: str, author: str, subject: str, creation_date: datetime
) -> plt.figure:

    plt.close("all")

    fig = plt.figure(figsize=(16, 9))
    _, ax = plt.subplots(1, 1)

    text = [
        TextArea(f"{title}", textprops=dict(fontsize=24, fontweight="bold")),
        TextArea(f"{subject}", textprops=dict(fontsize=18, fontstyle="italic")),
        TextArea(f"Author(s): {author}", textprops=dict(fontsize=12)),
        TextArea(
            f"Created: {creation_date.strftime('%d %b %Y')}",
            textprops=dict(fontsize=12),
        ),
    ]

    texts_vbox = VPacker(children=text, pad=10, sep=10)
    ann = AnnotationBbox(
        texts_vbox,
        (0, 1),
        xycoords=ax.transAxes,
        box_alignment=(0, 0),
        bboxprops=dict(color="black", facecolor="#1F78B4", boxstyle="round", alpha=0.5),
    )
    ann.set_figure(fig)
    fig.artists.append(ann)

    return fig


def generate_pdf(params, *plots: plt.figure, **kwargs):
    """
    Generate a PDF from figures. The function also gives the possibility to add
    bookmarks (controlled by "add_bookmarks"  parameters)

    Args:
        params: the parameters to use
        *plots: The figures to add to the PDF
        kwargs: keyword args. Currenty enables passing of a feature list for
        bookmarking.

    Returns:
        None
    """

    output_file = Path(
        Path(params["output_path"]).joinpath(
            f"{params['report_name']}_"
            f"{datetime.datetime.now().strftime('%Y%m%d_%H-%M-%S')}.pdf"
        )
        if params.get("timestamp", False)
        else Path(params["output_path"]).joinpath(f"{params['report_name']}.pdf")
    )

    with PdfPages(output_file) as pdf:

        title = params.get("title", "OptimusAI Report")
        author = params.get("author", "OptimusAI")
        subject = params.get("subject", "Report generated by OptimusAI")
        creation_date = datetime.datetime.today()

        pdf.savefig(_create_front_page(title, author, subject, creation_date))
        for plot in plots:
            if callable(plot):
                plot = plot()
            pdf.savefig(plot)

        _add_metadata(pdf, title, author, subject, creation_date)
    if params.get("add_bookmarks", False):
        _add_bookmarks(kwargs.get("bookmarks", []), output_file, params)


def generate_notebook(params, *figs: plt.figure):
    """
    Generate a notebook of matplotlib figures. To make this notebook
    runnable, each figure must contain the attribute `catalog_entry` which
    is the name of the catalog entry storing the figure. If this is not provided, the
    output will still be generated, but the notebook will not be runnable.

    See hooks.py in the plotting modular pipeline for adding the `catalog_entry`
    attribute.

    Args:
        params: the parameters to use
        *figs: the figures to output in the notebook

    Returns:
        None
    """

    def fig2img(fig):

        buf = io.BytesIO()
        fig.savefig(buf, format="png")
        buf.seek(0)
        return base64.b64encode(buf.read()).decode("utf-8").replace("\n", "")

    nb = nbf.v4.new_notebook()

    header_cell = nbf.v4.new_markdown_cell(
        f"# {params.get('title', 'OptimusAI Report')}\n"
        f"## {params.get('author', 'OptimusAI')}\n"
        f"{params.get('subject', 'Report generated by OptimusAI')}\n\n"
        f"_Created on {datetime.datetime.today().strftime('%d %b %Y')}_"
    )

    nb["cells"] = [
        header_cell,
        *[
            nbf.v4.new_code_cell(
                f"context.catalog.load("
                f"'{re.sub('[^A-Za-z0-9_]+', '', fig.catalog_entry)}')"
                if hasattr(fig, "catalog_entry")
                else "# outputs",
                outputs=[
                    nbf.v4.new_output(
                        output_type="display_data", data={"image/png": fig2img(fig)}
                    )
                ],
            )
            for fig in figs
        ],
    ]

    nbf.write(nb, params["output_file"])


def _add_bookmarks(bookmarks: List, input_path: Path, params: Dict[str, str]):
    """
    Read in an existing pdf report (typically batch analytics feature report)
     and add bookmarks to each page for easy navigation. Bookmarks are added to all
      features (default) or a user-provided list of bookmarks (specified in
      parameters)
    Args:
        bookmarks: list containing the file names of the individual pdf pages
        input_path: path to the existing pdf to be modified
        params: parameters to be used.
    """
    logger.info("Adding bookmarks to report")
    bookmarks_to_add = params.get("features_to_bookmark", [])
    if not bookmarks_to_add:
        # create bookmarks for all features
        bookmarks_to_add = bookmarks

    # load feature report without bookmarks
    input_file = open(input_path, mode="rb")
    input_report = PdfFileReader(input_file)
    n_pages = input_report.getNumPages()

    # output will contain the feature report with  bookmarks
    output_report = PdfFileWriter()

    for page in range(n_pages):
        # we need to build the output pdf from scratch
        output_report.addPage(input_report.getPage(page))
        # no bookmark for front page
        if page > 0:
            feat_name = bookmarks[page - 1]
            if feat_name in bookmarks_to_add:
                output_report.addBookmark(feat_name, page)

    output_path = Path(
        Path(params["output_path"]).joinpath(
            f"{params['report_name']}_"
            f"{datetime.datetime.now().strftime('%Y%m%d_%H-%M-%S')}.pdf"
        )
        if params.get("timestamp", False)
        else Path(params["output_path"]).joinpath(f"{params['report_name']}.pdf")
    )
    with open(output_path, mode="wb") as output_pdf:
        output_report.write(output_pdf)

    # Delete previous report with no bookmarks
    input_file.close()
    os.remove(input_path)


def generate_pdf_batch_analytics(
    params, feature_plots: Dict[str, Union[Callable, plt.Figure]]
):
    """
    Generate a PDF from figures. he function also gives the possibility to add
    bookmarks (controlled by "add_bookmarks"  parameters)

    Args:
        params: the parameters to use
        feature_plots: a dictionary that contains all plots
    Returns:
        None
    """
    generate_pdf(params, *feature_plots.values(), bookmarks=list(feature_plots.keys()))
